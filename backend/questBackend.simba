{$I WaspLib/osr.simba}
{$I WaspLib/optional/interfaces/mainscreen/anvil.simba}
{$SCOPEDENUMS ON}

begin // Set default account
  Login.PlayerIndex := 0;
end;

var //================DEFAULT SETTINGS==============================
  USE_HUD_REPORT:     Boolean                    = False;
  USE_GUI:            Boolean                    = True;
  QuestStartIndex:    Integer                    = 0;

type
  EState = (CHECK_INVENTORY, SOLVE_QUEST);
  STEP_TYPE = (INTERACT_NPC, KILL, INTERACT_OBJECT, INTERACT_INVENTORY, CONVERSATION, COMBINE, LOOT, WALK, WAIT, BANK, CLICK_TILE, CUSTOM);

  PStep = ^TStep;
  PQuest = ^TQuest;

  TStepEvent = procedure() of object;
  TStepCompletion = function(): Boolean of object;

  TStep = record
    step_type: STEP_TYPE;
    NPC_target: TRSNPCV2;
    objectTarget: TRSObjectV2;
    action, name, NPC_name, objName: String;
    item1, item2: TRSItem;
    coordinate: TPoint;
    time: Integer;
    bankItems: TRSItemArray;
    withdrawItems: TRSBankItemArray;
    conversationIndices: TIntegerArray;
    exceptions, actionSucceeded, completed, webWalk: Boolean;
    SpecialEvent: TStepEvent;
    CompletionCondition: TStepCompletion;
  end;

  TStepArray = array of TStep;

  TQuest = record(TBaseBankScript)
    steps: TStepArray;
    currentStep: TStep;
    index: Integer;

    questName, quitMessage: String;
    totalSteps: Integer;
    SetupProcedure: procedure() of object;
    region: array of TRSMapChunk;
    StartingConditions: function(quest: PQuest): boolean of object;
    completed, forceQuit: Boolean;
  end;

  TQuestArray = array of TQuest;

var
  QuestArray: TQuestArray;
  Quest: TQuest;

function TRSChat.HasContinue(): Boolean; override;
begin
  Result := Self.FindOption('continue', [CHAT_COLOR_BLUE, CHAT_COLOR_WHITE]) or
            Self.FindOption('Please wait', [CHAT_COLOR_BLUE, CHAT_COLOR_WHITE]);
end;

function TRSChat.ClickContinue(UseKeyboard: Boolean = True): Boolean; override;
begin
  if Self.ClickOption('continue', UseKeyboard, [CHAT_COLOR_BLUE, CHAT_COLOR_WHITE]) then
  begin
    Result := WaitUntil(Self.FindOption('Please wait', [CHAT_COLOR_BLUE, CHAT_COLOR_WHITE]), SRL.TruncatedGauss(50, 1500), 3000) and
              WaitUntil(not Self.FindOption('Please wait', [CHAT_COLOR_BLUE, CHAT_COLOR_WHITE]), SRL.TruncatedGauss(50, 1500), 3000);
  end;
end;

function TRSChat.ChatToNumber(Number: Integer): Boolean;
var
  Timeout: TCountdown;
begin
  Timeout.Init(15000);
  while (not Timeout.IsFinished) and self.HasContinue and Self.ClickContinue(False) do
    Wait(0, 2500, wdLeft);

  Keyboard.PressKey(VK_1 + Number);
  Wait(600,800);
  Result := True;
end;

function TRSInventory.ContainsAll(bankitems: TRSBankItemArray): Boolean; overload;
var
  bankitem: TRSBankItem;
  items: TRSItemArray;
  quantities: TIntegerArray;
  noted: TBoolArray;
  i: Integer;
begin
  for bankitem in bankitems do
  begin
    items += bankitem.Item;
    quantities += bankitem.Quantity;
    noted += bankitem.Noted;
  end;

  for i := 0 to high(items) do
  begin
    if noted[i] then
      result := self.CountItemStack(items[i]) >= quantities[i]
    else
      result := self.CountItem(items[i]) >= quantities[i];
    if not result then Exit(False);
  end;
end;

function TRSMapObject.WalkHover(attempts: Int32 = 2): Boolean; override;
var
  p: TPoint;
begin
  if ChooseOption.IsOpen() then
  begin
    if Self.Filter.UpText and ChooseOption.HasOption(Self.Name) then
      Exit(True);
    ChooseOption.Close();
  end;

  if not Self.Filter.Walker then Exit;

  if Self.Filter.UpText then Self.Walker^.TargetUpText := [Self.Name];

  p := Self.Walker^.GetClosestPoint(Self.Coordinates);
  if not Self.Walker^.WebWalk(p, 30, 0.15)
     and not Self.Walker^.MakePointVisible(p) then
      Exit;

  Result := Self._WalkHoverHelper(attempts, Self.TrackTarget);
end;

function TRSObjectV2Array.findNearest(point:TPoint): TRSObjectV2;
var
  obj: TRSObjectV2;
  dist: Double;
begin
  dist := $FFFFFF;
  for obj in self do
    if obj.Coordinates[0].DistanceTo(point) < dist then
    begin
      Result := obj;
      dist := obj.Coordinates[0].DistanceTo(point);
    end;
end;

function TRSNPCV2Array.findNearest(point:TPoint): TRSNPCV2;
var
  NPC: TRSNPCV2;
  dist: Double;
begin
  dist := $FFFFFF;
  for NPC in self do
    if NPC.Coordinates[0].DistanceTo(point) < dist then
    begin
      Result := NPC;
      dist := NPC.Coordinates[0].DistanceTo(point);
    end;
end;

function TRSMainscreen.IsInCombat(): Boolean;
var
  timer: TCountdown;
  hits: Integer;
begin
  timer.Init(5500);
  while not timer.IsFinished do
  begin
    hits := Length(Mainscreen.FindHitsplats(Mainscreen.GetPlayerBox.Expand(15)));
    if hits > 0 then Exit(True);
    if XPBar.EarnedXP then Exit(True);
  end;
  Result := False;
end;

function TRSGameTabs.Open(Tab: ERSGameTab; force: Boolean): Boolean; overload;
var
  i: Int32;
begin
  if not force and (Self.GetCurrentTab() = Tab) then
    Exit(True);

  for i := 1 to 3 do
  begin
    Mouse.Click(GetTabBox(Tab), MOUSE_LEFT, SRL.Dice(50));

    Result := WaitUntil(Self.GetCurrentTab() = Tab, SRL.TruncatedGauss(50, 2000), SRL.TruncatedGauss(2000, 3000));
    if Result then
      Exit;
  end;
end;

procedure TRSMap.ClickTile(coord: TPoint; Action: String = '');
var
  rect: TRectangle;
begin
  rect := self.GetTileMS(coord);
  Mouse.Move(rect.Mean);
  if Action <> '' then
    ChooseOption.Select(Action)
  else
    Mouse.Click(MOUSE_LEFT);
end;

procedure TAntiban.Setup(); override;
begin
  Self.Skills := [ERSSkill.TOTAL];
  Self.MinZoom := 0;
  Self.MaxZoom := 25;
  inherited;
end;

function StandardCompletion(): Boolean;
  begin
    if Quest.currentStep.actionSucceeded then Exit(True);
    Result := False;
  end;

function TQuest.SetupInteractNpcStep(stepName, NPC_name, action: String; WebWalk: Boolean = True; Coordinate: TPoint = [0,0]; CompletionCondition: TStepCompletion = nil; SpecialEvent: TStepEvent = nil): TStep;
begin
  Result.step_type := STEP_TYPE.INTERACT_NPC;
  Result.name := stepName;
  Result.NPC_name := NPC_name;
  Result.action := action;
  Result.coordinate := coordinate;
  Result.webWalk := WebWalk;
  if @CompletionCondition = nil then
    Result.CompletionCondition := @StandardCompletion
  else
    Result.CompletionCondition := @CompletionCondition;
  Result.SpecialEvent := @SpecialEvent;
end;

function TQuest.SetupInteractObjectStep(stepName, objectName, action: String; WebWalk: Boolean = True; Coordinate: TPoint = [0,0]; CompletionCondition: TStepCompletion = nil; SpecialEvent: TStepEvent = nil): TStep;
begin
  Result.step_type := STEP_TYPE.INTERACT_OBJECT;
  Result.name := stepName;
  Result.objName := objectName;
  Result.action := action;
  Result.coordinate := coordinate;
  Result.webWalk := WebWalk;
  if @CompletionCondition = nil then
    Result.CompletionCondition := @StandardCompletion
  else
    Result.CompletionCondition := @CompletionCondition;
  Result.SpecialEvent := @SpecialEvent;
end;

function TQuest.SetupConversationStep(stepName: String; conversationIndices: TIntegerArray; CompletionCondition: TStepCompletion = nil; SpecialEvent: TStepEvent = nil): TStep;
begin
  Result.step_type := STEP_TYPE.CONVERSATION;
  Result.name := stepName;
  Result.conversationIndices := conversationIndices;
  if @CompletionCondition = nil then
    Result.CompletionCondition := @StandardCompletion
  else
    Result.CompletionCondition := @CompletionCondition;
  Result.SpecialEvent := @SpecialEvent;
end;

function TQuest.SetupInteractInventoryStep(stepName: String; item: TRSItem; action: String; CompletionCondition: TStepCompletion = nil; SpecialEvent: TStepEvent = nil): TStep;
begin
  Result.step_type := STEP_TYPE.INTERACT_INVENTORY;
  Result.name := stepName;
  Result.item1 := item;
  Result.action := action;
  if @CompletionCondition = nil then
    Result.CompletionCondition := @StandardCompletion
  else
    Result.CompletionCondition := @CompletionCondition;
  Result.SpecialEvent := @SpecialEvent;
end;

function TQuest.SetupCombineStep(stepName: String; item1, item2: TRSItem; CompletionCondition: TStepCompletion = nil; SpecialEvent: TStepEvent = nil): TStep;
begin
  Result.step_type := STEP_TYPE.COMBINE;
  Result.name := stepName;
  Result.item1 := item1;
  Result.item2 := item2;
  if @CompletionCondition = nil then
    Result.CompletionCondition := @StandardCompletion
  else
    Result.CompletionCondition := @CompletionCondition;
  Result.SpecialEvent := @SpecialEvent;
end;

function TQuest.SetupBankStep(stepName: String; bankItems: TRSItemArray; withdrawItems: TRSBankItemArray; CompletionCondition: TStepCompletion = nil; SpecialEvent: TStepEvent = nil): TStep;
begin
  Result.step_type := STEP_TYPE.BANK;
  Result.name := stepName;
  Result.bankItems := bankItems;
  Result.withdrawItems := withdrawItems;
  if @CompletionCondition = nil then
    Result.CompletionCondition := @StandardCompletion
  else
    Result.CompletionCondition := @CompletionCondition;
  Result.SpecialEvent := @SpecialEvent;
end;

function TQuest.SetupKillStep(stepName, NPC_name: String; time: Integer = 7000; WebWalk: Boolean = True; Coordinate: TPoint = [0,0]; CompletionCondition: TStepCompletion = nil; SpecialEvent: TStepEvent = nil): TStep;
begin
  Result.step_type := STEP_TYPE.KILL;
  Result.name := stepName;
  Result.NPC_name := NPC_name;
  Result.time := time;
  Result.coordinate := coordinate;
  Result.webWalk := WebWalk;
  if @CompletionCondition = nil then
    Result.CompletionCondition := @StandardCompletion
  else
    Result.CompletionCondition := @CompletionCondition;
  Result.SpecialEvent := @SpecialEvent;
end;

function TQuest.SetupWalkStep(stepName: String; Coordinate: TPoint; CompletionCondition: TStepCompletion = nil; SpecialEvent: TStepEvent = nil): TStep;
begin
  Result.step_type := STEP_TYPE.WALK;
  Result.name := stepName;
  Result.coordinate := coordinate;
  if @CompletionCondition = nil then
    Result.CompletionCondition := @StandardCompletion
  else
    Result.CompletionCondition := @CompletionCondition;
  Result.SpecialEvent := @SpecialEvent;
end;

function TQuest.SetupWaitStep(stepName: String; time: Integer; CompletionCondition: TStepCompletion = nil; SpecialEvent: TStepEvent = nil): TStep;
begin
  Result.step_type := STEP_TYPE.WAIT;
  Result.name := stepName;
  Result.time := time;
  if @CompletionCondition = nil then
    Result.CompletionCondition := @StandardCompletion
  else
    Result.CompletionCondition := @CompletionCondition;
  Result.SpecialEvent := @SpecialEvent;
end;

function TQuest.SetupClickTileStep(stepName: String; Coordinate: TPoint; Action: String = ''; CompletionCondition: TStepCompletion = nil; SpecialEvent: TStepEvent = nil): TStep;
begin
  Result.step_type := STEP_TYPE.CLICK_TILE;
  Result.name := stepName;
  Result.coordinate := coordinate;
  Result.action := Action;
  if @CompletionCondition = nil then
    Result.CompletionCondition := @StandardCompletion
  else
    Result.CompletionCondition := @CompletionCondition;
  Result.SpecialEvent := @SpecialEvent;
end;

function TQuest.SetupCustomStep(stepName: String; CompletionCondition: TStepCompletion = nil; SpecialEvent: TStepEvent = nil): TStep;
begin
  Result.step_type := STEP_TYPE.CUSTOM;
  Result.name := stepName;
  if @CompletionCondition = nil then
    Result.CompletionCondition := @StandardCompletion
  else
    Result.CompletionCondition := @CompletionCondition;
  Result.SpecialEvent := @SpecialEvent;
end;

procedure TQuest.SolveInteractNpcStep(var step: TStep);
var
  npcArr: TRSNPCV2Array;
begin
  step.actionSucceeded := False;

  if step.coordinate = [0,0] then step.coordinate := Map.Walker.Position();

  npcArr := NPCs.GetAll(step.NPC_name);
  step.NPC_target := npcArr.findNearest(step.coordinate);
  Debug(step.NPC_target);

  if step.webwalk then
    step.actionSucceeded := step.NPC_target.WalkSelectOption([step.action],5)
  else
    step.actionSucceeded := step.NPC_target.SelectOption([step.action],5);
  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  step.completed := step.CompletionCondition();
end;

procedure TQuest.SolveKillStep(var step: TStep);
var
  npcArr: TRSNPCV2Array;
begin
  step.actionSucceeded := False;

  if step.coordinate = [0,0] then step.coordinate := Map.Walker.Position();

  npcArr := NPCs.GetAll(step.NPC_name);
  step.NPC_target := npcArr.findNearest(step.coordinate);
  Debug(step.NPC_target);

  xpbar.EarnedXP();

  if step.webwalk then
    step.NPC_target.WalkSelectOption(['Attack'],5)
  else
    step.NPC_target.SelectOption(['Attack'],5);

  if not WaitUntil(Mainscreen.IsInCombat, 50, 5000) then
  begin
    step.actionSucceeded := False;
    Exit();
  end;
  step.actionSucceeded := True;
  WaitUntil(not Mainscreen.IsInCombat, 50, step.time);

  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  step.completed := step.CompletionCondition();
end;

procedure TQuest.SolveInteractObjectStep(var step: TStep);
var
  objArr: TRSObjectV2Array;
begin
  step.actionSucceeded := False;

  if step.coordinate = [0,0] then step.coordinate := Map.Walker.Position();

  objArr := Objects.GetAll(step.objName);
  step.objectTarget := objArr.findNearest(step.coordinate);
  Debug(step.objectTarget);

  if step.webwalk then
    step.actionSucceeded := step.objectTarget.WalkSelectOption([step.action],5)
  else
    step.actionSucceeded := step.objectTarget.SelectOption([step.action],5);
  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  step.completed := step.CompletionCondition();
end;

procedure TQuest.SolveInteractInventoryStep(var step: TStep);
var
  slots: TIntegerArray;
begin
  step.actionSucceeded := False;
  if not Inventory.IsOpen() then Inventory.Open();
  if not Inventory.ContainsItem(step.item1) then Exit;

  Inventory.FindItem(step.item1, slots);
  step.actionSucceeded := Inventory.ClickSlot(slots[0], [step.action]);

  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  step.completed := step.CompletionCondition();
end;

procedure TQuest.SolveConversationStep(var step: TStep);
var
  i: Integer;
begin
  step.actionSucceeded := False;
  WaitUntil(chat.HasContinue,10,2000);
  Writeln('Starting conversation');
  for i in step.conversationIndices do
    Chat.ChatToNumber(i-1);
  while chat.HasContinue() do
  begin
    chat.ClickContinue(False);
    Wait(0,700,wdLeft);
  end;

  step.actionSucceeded := True;
  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  step.completed := step.CompletionCondition();
end;

procedure TQuest.SolveCombineStep(var step: TStep);
begin
  step.actionSucceeded := False;
  if not Inventory.IsOpen() then Inventory.Open();
  if not Inventory.ContainsItem(step.item1) then Exit;
  if not Inventory.ContainsItem(step.item2) then Exit;

  step.actionSucceeded := Inventory.Use(step.item1,step.item2);
  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  step.completed := step.CompletionCondition();
end;

procedure TQuest.SolveLootStep(var step: TStep);
begin

end;

procedure TQuest.SolveBankStep(var step: TStep);
var
  bankItem: TRSBankItem;
begin
  step.actionSucceeded := False;
  if inventory.ContainsAll(step.bankItems) then
  begin
    step.actionSucceeded := True;
    Exit();
  end;

  banks.WalkOpen();
  if not WaitUntil(Bank.IsOpen,100,10000) then Exit();

  Bank.DepositItems(Step.bankItems, True);
  for bankItem in step.withdrawItems do
    Bank.WithdrawItem(bankItem, False);

  bank.Close;

  step.actionSucceeded := Inventory.ContainsAll(step.withdrawItems);

  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  step.completed := step.CompletionCondition();
end;

procedure TQuest.SolveWalkStep(var step: TStep);
begin
  if Map.Walker.Position = step.coordinate then
  begin
    step.actionSucceeded := True;
  end else
    Step.actionSucceeded := Map.Walker.WebWalk(step.coordinate);
  WaitUntil(not Minimap.IsPlayerMoving, 50,5000);
  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  step.completed := step.CompletionCondition();
end;

procedure TQuest.SolveWaitStep(var step: TStep);
begin
  Wait(step.time, step.time + 600);
  step.actionSucceeded := True;
  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  step.completed := step.CompletionCondition();
end;

procedure TQuest.SolveClickTileStep(var step: TStep);
begin
  step.actionSucceeded := True;
  Map.ClickTile(step.coordinate, step.action);
  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  step.completed := step.CompletionCondition();
end;

procedure TQuest.SolveCustomStep(var step: TStep);
begin
  step.actionSucceeded := True;
  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  step.completed := step.CompletionCondition();
end;

function customCompletion1(): Boolean;
begin
  Result := Gametabs.Open(ERSGameTab.INVENTORY, True);
end;

function customCompletion2(): Boolean;
begin
  WaitUntil(Inventory.ContainsItem('Raw shrimps'), 50, 10000);
  Result := Gametabs.Open(ERSGameTab.STATS, True);
end;

function customCompletion3(): Boolean;
begin
  Result := WaitUntil(Inventory.ContainsItem('Logs'), 50, 10000);
  Quest.steps[quest.index].coordinate := Map.Walker.Position();
end;

function customCompletion4(): Boolean;
begin
  Inventory.ClickItem('Raw shrimps');
  Map.ClickTile(Quest.steps[quest.index - 3].coordinate , '-> Fire');
  Result := WaitUntil(Inventory.ContainsItem('Shrimps'), 50, 10000);
end;

function customCompletion5(): Boolean;
begin
  Result := Gametabs.Open(ERSGameTab.QUESTS, True);
end;

function customCompletion6(): Boolean;
begin
  Result := WaitUntil(Inventory.ContainsItem('Tin ore'), 50, 10000);
end;

function customCompletion7(): Boolean;
begin
  Result := WaitUntil(Inventory.ContainsItem('Copper ore'), 50, 10000);
end;

function customCompletion8(): Boolean;
begin
  Result := WaitUntil(Inventory.ContainsItem('Bronze bar'), 50, 10000);
end;

function customCompletion10(): Boolean;
begin
  WaitUntil(RSInterface.IsOpen, 50,5000);
  Anvil.SmithItem('Bronze dagger', ERSAnvilButton.QUANTITY_ALL);
  Result := WaitUntil(Inventory.ContainsItem('Bronze dagger'), 50, 10000);
end;

function customCompletion11(): Boolean;
begin
  Gametabs.Open(ERSGameTab.EQUIPMENT, True);
  Equipment.GetButton(ERSEquipmentbutton.STATS).Click;
  WaitUntil(RSInterface.IsOpen, 50,5000);
  RSInterface.Close(False);
  Result := Inventory.ClickItem('Bronze dagger');
end;

function customCompletion12(): Boolean;
begin
  Wait(1000);
  Result := Gametabs.Open(ERSGameTab.COMBAT, True);
end;

function customCompletion13(): Boolean;
begin
  WaitUntil(RSInterface.IsOpen, 50,5000);
  Result := RSInterface.Close(False);
end;

function customCompletion15(): Boolean;
begin
  Result := Gametabs.Open(ERSGameTab.ACCOUNT, True);
end;

function customCompletion16(): Boolean;
begin
  Result := Gametabs.Open(ERSGameTab.PRAYER, True);
end;

function customCompletion17(): Boolean;
begin
  Result := Gametabs.Open(ERSGameTab.FRIENDS, True);
end;

function customCompletion18(): Boolean;
begin
  Minimap.SetCompassAngle(180);
  Result := True;
end;

function customCompletion19(): Boolean;
begin
  Result := WaitUntil(Map.Position.InRange([8392, 38022],3),50,7000);
end;

function customCompletion20(): Boolean;
begin
  Result := Gametabs.Open(ERSGameTab.MAGIC, True);
end;

function customCompletion21(): Boolean;
var
  tries: Integer;
  npcArr: TRSNPCV2Array;
  npc: TRSNPCV2;
  tpa: TPointArray;
  atpa: T2DPointArray;
begin
  tries := 0;
  npcArr := NPCs.getAll('Chicken');
  npc := npcArr.findNearest(Map.Position);
  while (tries < 5) and not Result do
  begin
    if not Magic.IsSelected(ERSSPell.WIND_STRIKE) then Magic.ClickSpell(ERSSPELL.WIND_STRIKE);

    npc.find(atpa);

    for tpa in atpa do
    begin
      Mouse.move(tpa.mean());
      if Mainscreen.IsUpText('-> Chicken') then Mouse.Click(MOUSE_LEFT);
    end;
    Tries += 1;
    if (length(Chat.GetOptions) = 2) or (length(Chat.GetOptions) = 3) then Result := True
  end;
end;

function customCompletion22(): Boolean;
begin
  Keyboard.Send('::toggleroofs', VK_ENTER);
  Result := True;
end;

procedure customAction1();
begin
  Minimap.SetCompassAngle(0);
end;

function CooksStart(quest: PQuest): Boolean;
begin
  quest^.DebugLn('Starting condition: ' + BoolToStr(Inventory.ContainsAll(['Egg','Bucket of milk','Pot of flour'])));
  Exit(Inventory.ContainsAll(['Egg','Bucket of milk','Pot of flour']));
end;

function SheepStart(quest: PQuest): Boolean;
begin
  Exit(Inventory.CountItem('Ball of wool') >= 20);
end;

function DoricStart(quest: PQuest): Boolean;
begin
  Exit((Inventory.CountItem('Clay') >= 6) and (Inventory.CountItem('Copper ore') >= 4) and (Inventory.CountItem('Iron ore') >= 2));
end;

function EmptyStart(quest: PQuest): Boolean;
begin
  Exit(True);
end;

procedure SetupCooksAssistant();
begin
  Quest.region := [[[50,50,50,50],[0]]];
  Quest.StartingConditions := @CooksStart;

  Map.SetupChunks(Quest.region);
  NPCs.Setup(Map.NPCs(), @Map.Walker);
  Objects.Setup(Map.Objects(), @Map.Walker);

  Quest.steps += Quest.SetupInteractNpcStep('Talk to cook', 'Cook', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Finish cook conversation', [1,1]);
end;

procedure SetupSheepShearer();
begin
  Quest.region := [[[49,51,50,50],[0]]];
  Quest.StartingConditions := @SheepStart;

  Map.SetupChunks(Quest.region);
  NPCs.Setup(Map.NPCs(), @Map.Walker);
  Objects.Setup(Map.Objects(), @Map.Walker);

  Quest.steps += Quest.SetupInteractNpcStep('Talk to Fred', 'Fred the Farmer', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Finish Fred conversation', [1]);
end;

procedure SetupDorics();
begin
  Quest.region := [[[46,54,46,52],[0]]];
  Quest.StartingConditions := @DoricStart;

  Map.SetupChunks(Quest.region);
  NPCs.Setup(Map.NPCs(), @Map.Walker);
  Objects.Setup(Map.Objects(), @Map.Walker);

  Quest.steps += Quest.SetupInteractNpcStep('Talk to Doric', 'Doric', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Finish Doric conversation', [1,1]);
end;

procedure SetupRomeoAndJuliet();
begin

end;

procedure SetupTutorial();
begin
  Quest.region := [[[47,49,49,47],[0]], [[25,195,26,195],[0]]];
  Quest.StartingConditions := @EmptyStart;

  Map.SetupChunks(Quest.region);
  NPCs.Setup(Map.NPCs(), @Map.Walker);
  Objects.Setup(Map.Objects(), @Map.Walker);

  Quest.steps += Quest.SetupInteractNpcStep('Talk to Gielinor Guide', 'Gielinor Guide', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Gielinor guide', []); //
  Quest.steps += Quest.SetupInteractNpcStep('Talk to Survival Expert', 'Survival Expert', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Survival Expert', [], @customCompletion1); //open invy
  Quest.steps += Quest.SetupWalkStep('Walk to fishing spot', [8308, 38058]);
  Quest.steps += Quest.SetupClickTileStep('Click fishing spot', [8308, 38062], 'Net', @customCompletion2); //waitUntil fish and click stats
  Quest.steps += Quest.SetupInteractNpcStep('Talk to Survival Expert 2', 'Survival Expert', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Survival Expert 2', []);
  Quest.steps += Quest.SetupWalkStep('Walk to tree', [8324, 38042], nil, @customAction1); //rotate North
  Quest.steps += Quest.SetupClickTileStep('Click tree', [8324, 38034], 'Chop', @customCompletion3); //waitUntil log  and save pos
  Quest.steps += Quest.SetupCombineStep('Light fire', 'Tinderbox', 'Logs');
  Quest.steps += Quest.SetupWaitStep('Wait for fire to burn', 6000);
  Quest.steps += Quest.SetupCustomStep('Click shrimps on fire', @customCompletion4); //click shrimp on fire and waituntil shrimps
  Quest.steps += Quest.SetupInteractNpcStep('Talk to Master Chef', 'Master Chef', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Master Chef', []);
  Quest.steps += Quest.SetupCombineStep('Make Dough', 'Pot of flour', 'Bucket of water');
  Quest.steps += Quest.SetupInteractObjectStep('Click range', 'Range', 'Cook', False);
  Quest.steps += Quest.SetupWaitStep('Wait for bread', 3000);
  Quest.steps += Quest.SetupInteractNpcStep('Talk to Quest Guide', 'Quest Guide', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Quest Guide', [], @customCompletion5); //open questtab
  Quest.steps += Quest.SetupInteractNpcStep('Talk to Quest Guide 2', 'Quest Guide', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Quest Guide 2', []);
  Quest.steps += Quest.SetupInteractObjectStep('Click ladder', 'Ladder', 'Climb-down', False);
  Quest.steps += Quest.SetupWaitStep('Wait until downstairs', 3000);
  Quest.steps += Quest.SetupInteractNpcStep('Talk to Mining Instructor', 'Mining Instructor', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Mining Instructor', []);
  Quest.steps += Quest.SetupInteractObjectStep('Mine tin', 'Tin rocks', 'Mine', True, [0,0], @customCompletion6); // wait tin ore
  Quest.steps += Quest.SetupInteractObjectStep('Mine copper', 'Copper rocks', 'Mine', True, [0,0], @customCompletion7); // wait copper ore
  Quest.steps += Quest.SetupInteractObjectStep('Smelt bronze', 'Furnace', 'Use', True, [0,0], @customCompletion8); // wait bronze bar
  Quest.steps += Quest.SetupInteractNpcStep('Talk to Mining Instructor 2', 'Mining Instructor', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Mining Instructor', []);
  Quest.steps += Quest.SetupInteractObjectStep('Click anvil', 'Anvil', 'Smith', True, [0,0], @customCompletion10);  // wait till interface and smith bronze dagger and wait till bronze dagger
  Quest.steps += Quest.SetupInteractNpcStep('Talk to Combat Instructor', 'Combat Instructor', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Combat Instructor', [], @customCompletion11); //open equipment click gear quit gear click dagger
  Quest.steps += Quest.SetupInteractNpcStep('Talk to Combat Instructor 2', 'Combat Instructor', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Combat Instructor 2', []);
  Quest.steps += Quest.SetupInteractInventoryStep('click sword', 'Bronze sword', 'Wield');
  Quest.steps += Quest.SetupInteractInventoryStep('click shield', 'Wooden shield', 'Wield', @customCompletion12); // wait 1000 open combat tab
  Quest.steps += Quest.SetupWalkStep('Walk in cage', [2684, 322]);
  Quest.steps += Quest.SetupKillStep('Kill rat', 'Giant rat', 3000, True);
  Quest.steps += Quest.SetupInteractNpcStep('Talk to Combat Instructor 3', 'Combat Instructor', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Combat Instructor 3', []);
  Quest.steps += Quest.SetupInteractInventoryStep('click bow', 'Shortbow', 'Wield');
  Quest.steps += Quest.SetupInteractInventoryStep('click arrows', 'Bronze arrow', 'Wield');
  Quest.steps += Quest.SetupKillStep('Kill rat', 'Giant rat', 5000, False);
  Quest.steps += Quest.SetupInteractObjectStep('Click ladder', 'Ladder', 'Climb-up', True, [2720, 310]);
  Quest.steps += Quest.SetupWaitStep('Wait until upstairs', 3000);
  Quest.steps += Quest.SetupWalkStep('Walk to bank', [8384, 37938]);
  Quest.steps += Quest.SetupInteractNpcStep('Talk to banker', 'Banker', 'Talk-to', False, [0,0], @customCompletion13); //wait bank open and close it
  Quest.steps += Quest.SetupClickTileStep('Click poll booth', [8380, 37946], 'Use');
  Quest.steps += Quest.SetupWaitStep('wait lil bit', 1000);
  Quest.steps += Quest.SetupConversationStep('Conversation poll booth', [], @customCompletion13); //close interface
  Quest.steps += Quest.SetupInteractNpcStep('Talk to Account Guide', 'Account Guide', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Account Guide', [], @customCompletion15); //open account
  Quest.steps += Quest.SetupInteractNpcStep('Talk to Account Guide 2', 'Account Guide', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Account Guide 2', []);
  Quest.steps += Quest.SetupInteractNpcStep('Talk to prayer dude', 'Brother Brace', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Brother Brace', [], @customCompletion16); //open prayer
  Quest.steps += Quest.SetupInteractNpcStep('Talk to prayer dude 2', 'Brother Brace', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Brother Brace 2', [], @customCompletion17); //open friends
  Quest.steps += Quest.SetupInteractNpcStep('Talk to prayer dude 3', 'Brother Brace', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Brother Brace 3', [], @customCompletion18); //rotate south
  Quest.steps += Quest.SetupClickTileStep('click door', [8392, 38022], 'Open', @customCompletion19); // wait till in right area
  Quest.steps += Quest.SetupWalkStep('Walk to magic dude', [8468, 38074]);
  Quest.steps += Quest.SetupInteractNpcStep('Talk to magic dude', 'Magic Instructor', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Magic dude', [], @customCompletion20); //open magic tab
  Quest.steps += Quest.SetupInteractNpcStep('Talk to magic dude 2', 'Magic Instructor', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Magic dude 2', []); //open magic tab
  Quest.steps += Quest.SetupWalkStep('Walk to cage', [8464, 38066]);
  Quest.steps += Quest.SetupCustomStep('cast spell on chicken', @customCompletion21);
  Quest.steps += Quest.SetupInteractNpcStep('Talk to magic dude 3', 'Magic Instructor', 'Talk-to');
  Quest.steps += Quest.SetupConversationStep('Conversation Magic dude 3', [1,3]); //open magic tab
  Quest.steps += Quest.SetupWaitStep('wait few seconds', 4000);
  Quest.steps += Quest.SetupConversationStep('Conversation Lumbridge', []);
  Quest.steps += Quest.SetupCustomStep('Hide roofs', @customCompletion22); // Keyboard.Send(Answer, VK_ENTER)
end;

procedure TQuestArray.AddQuest(name: String; steps: Integer; setup: procedure() of object);
var
  addedQuest: TQuest;
begin
  addedQuest.questName := name;
  addedQuest.totalSteps := steps;
  addedQuest.SetupProcedure := @setup;
  self += addedQuest;
end;

begin
  QuestArray.AddQuest('Cook''s Assistant', 2, @SetupCooksAssistant);
  QuestArray.AddQuest('Sheep Shearer', 2, @SetupSheepShearer);
  QuestArray.AddQuest('Dorics Quest', 2, @SetupDorics);
  QuestArray.AddQuest('Tutorial Island', 75, @SetupTutorial);
end;

procedure TQuest.Init(MaxActions: UInt32; MaxTime: UInt64); override;
begin
  inherited;
  WLSettings.RemoteInput.HUDReport  := USE_HUD_REPORT;
  Mouse.Speed                       := Random(20,24);
  Self.DisableDebugging             := False;
  Mouse.Distribution                := MOUSE_DISTRIBUTION_GAUSS;
  if Options.GetBrightnessLevel < 100 then
    Options.SetMaxBrightness;
  Self.PrintTimer.Init(5 * ONE_SECOND);
  Self.SetupProcedure();
  Self.index := QuestStartIndex;
end;

procedure TQuest.Run(MaxActions: UInt32; MaxTime: UInt64);
var
  currentIndex: Integer;
  attempts: Integer;
begin
  Self.Init(MaxActions, MaxTime);
  attempts := 0;
  if not self.StartingConditions(@self) then TerminateScript('Starting conditions not satisfied');
  while self.index <= high(self.steps) do
  begin
    currentIndex := self.index;
    Self.currentStep := self.steps[currentIndex];
    self.DebugLn('Executing step ' + IntToStr(currentIndex + 1) + ': ' + self.currentStep.name);
    WriteLn(currentStep.step_type);
    case currentStep.step_type of
      STEP_TYPE.INTERACT_NPC: Self.SolveInteractNPCStep(currentStep);
      STEP_TYPE.KILL: Self.SolveKillStep(currentStep);
      STEP_TYPE.INTERACT_OBJECT: Self.SolveInteractObjectStep(currentStep);
      STEP_TYPE.INTERACT_INVENTORY: Self.SolveInteractInventoryStep(currentStep);
      STEP_TYPE.CONVERSATION: Self.SolveConversationStep(currentStep);
      STEP_TYPE.COMBINE: Self.SolveCombineStep(currentStep);
      STEP_TYPE.LOOT: Self.SolveLootStep(currentStep);
      STEP_TYPE.BANK: Self.SolveBankStep(currentStep);
      STEP_TYPE.WALK: Self.SolveWalkStep(currentStep);
      STEP_TYPE.WAIT: Self.SolveWaitStep(currentStep);
      STEP_TYPE.CLICK_TILE: Self.SolveClickTileStep(currentStep);
      STEP_TYPE.CUSTOM: Self.SolveCustomStep(currentStep);
    end;

    if self.forceQuit then TerminateScript(self.Quitmessage);

    if currentStep.completed then
    begin
      self.index += 1;
      DebugLn('Step Solved, going to next step');
      Wait(1000);
      attempts := 0;
      Continue;
    end else
      attempts += 1;
    DebugLn('Step failed on try ' + IntToStr(attempts));
    Antiban.RandomRotate();
    if attempts > 5 then TerminateScript('Failed to solve step: ' + currentStep.name + ' with index ' + IntToStr(self.index + 1));
  end;
  DebugLn('Quest solved');
end;

type
  TQuestConfig = record(TScriptForm)
    StepSelector, questSelector: TLabeledCombobox;
  end;

function TQuestArray.GetQuestNames(): TStringArray;
var
  quest: TQuest;
begin
  for quest in self do
    Result += quest.questName;
end;

function TQuest.GetStepsArray(): TStringArray;
var
  i: Integer;
begin
  for i := 1 to self.totalSteps do
    Result += IntToStr(i);
end;

procedure TQuestConfig.changeSteps(sender: TObject);
begin
  Self.StepSelector.Clear();
  Self.StepSelector.AddItemArray(QuestArray[self.questSelector.GetItemIndex].GetStepsArray);
  self.StepSelector.SetItemIndex(0);
end;

procedure TQuestConfig.StartScript(sender: TObject); override;
begin
  Quest := QuestArray[self.QuestSelector.getItemIndex];
  QuestStartIndex := self.StepSelector.GetItemIndex;
  inherited;
end;

procedure TQuestConfig.Run(); override;
var
  tab: TTabSheet;
  i: integer;
  OptionsArray: TStringArray;
begin
  Self.Setup('QuestSolver Config');
  Self.Start.SetOnClick(@Self.StartScript);

  Self.AddTab('Script Settings');
  tab := Self.Tabs[High(Self.Tabs)];
  Self.CreateAccountManager(tab);

  with Self.questSelector do
  begin
    Create(tab);
    SetCaption('Quest:');
    SetLeft(TControl.AdjustToDPI(50));
    SetTop(200);
    SetStyle(csDropDownList);
    AddItemArray(QuestArray.GetQuestNames);
    SetItemIndex(0);
    Combobox.setOnChange(@Self.changeSteps);
  end;

  with Self.StepSelector do
  begin
    Create(tab);
    SetCaption('Step at which to start:');
    SetLeft(TControl.AdjustToDPI(50));
    SetTop(250);
    SetStyle(csDropDownList);
    AddItemArray(QuestArray[self.questSelector.GetItemIndex].GetStepsArray);
    SetItemIndex(0);
  end;


  Self.CreateVersionPanel(tab);
  Self.CreateAntibanManager();
  Self.CreateWaspLibSettings();
  Self.CreateAPISettings();

  inherited;
end;

var
  QuestConfig: TQuestConfig;

begin
  if USE_GUI then
    QuestConfig.Run();
 Quest.Run(WLSettings.MaxActions, WLSettings.MaxTime);
end.
