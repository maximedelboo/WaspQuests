{$DEFINE WQ_BACKEND}
{$IFNDEF WQ_OSR}
  {$I WaspQuests/osr.simba}
{$ENDIF}

{$I WaspLib/optional/interfaces/mainscreen/anvil.simba}
{$SCOPEDENUMS ON}

var
  questStartIndex: Integer = 0;

procedure TAntiban.Setup(); override;
begin
  Self.Skills := [ERSSkill.TOTAL];
  Self.MinZoom := 0;
  Self.MaxZoom := 25;
  inherited;
end;

function EmptyStart(quest: PQuest): Boolean;
begin
  Exit(True);
end;

procedure TQuest.Free();
var
  emptyQuest: TQuest;
begin
  Self := emptyQuest;
end;

procedure TQuestArray.AddQuest(name: String; setup: procedure() of object);
var
  addedQuest: TQuest;
begin
  addedQuest.questName := name;
  addedQuest.SetupProcedure := @setup;
  self += addedQuest;
end;

procedure TQuest.Init(MaxActions: UInt32; MaxTime: UInt64); override;
begin
  inherited;
  WLSettings.RemoteInput.HUDReport  := False;
  Mouse.Speed                       := Random(20,24);
  Self.DisableDebugging             := False;
  Mouse.Distribution                := MOUSE_DISTRIBUTION_GAUSS;
  if Options.GetBrightnessLevel < 100 then
    Options.SetMaxBrightness;
  Self.PrintTimer.Init(5 * ONE_SECOND);
  Self.SetupProcedure();

  Self.DebugLn('Setting up map, this can take a second');
  Map.SetupChunks(Quest.region);
  NPCs.Setup(Map.NPCs(), @Map.Walker);
  Objects.Setup(Map.Objects(), @Map.Walker);

  Self.index := QuestStartIndex;
end;

procedure TQuest.Solve();
var
  currentIndex: Integer;
  attempts: Integer;
begin
  attempts := 0;
  if not self.StartingConditions(@self) then TerminateScript('Starting conditions not satisfied');
  while self.index <= high(self.steps) do
  begin
    currentIndex := self.index;
    Self.currentStep := self.steps[currentIndex];
    self.DebugLn('Executing step ' + IntToStr(currentIndex + 1) + ': ' + self.currentStep.name);
    WriteLn(currentStep.step_type);
    case currentStep.step_type of
      STEP_TYPE.INTERACT_NPC: Self.SolveInteractNPCStep(currentStep);
      STEP_TYPE.KILL: Self.SolveKillStep(currentStep);
      STEP_TYPE.INTERACT_OBJECT: Self.SolveInteractObjectStep(currentStep);
      STEP_TYPE.INTERACT_INVENTORY: Self.SolveInteractInventoryStep(currentStep);
      STEP_TYPE.CONVERSATION: Self.SolveConversationStep(currentStep);
      STEP_TYPE.COMBINE: Self.SolveCombineStep(currentStep);
      STEP_TYPE.LOOT: Self.SolveLootStep(currentStep);
      STEP_TYPE.BANK: Self.SolveBankStep(currentStep);
      STEP_TYPE.WALK: Self.SolveWalkStep(currentStep);
      STEP_TYPE.WAIT: Self.SolveWaitStep(currentStep);
      STEP_TYPE.CLICK_TILE: Self.SolveClickTileStep(currentStep);
      STEP_TYPE.CUSTOM: Self.SolveCustomStep(currentStep);
    end;

    if self.forceQuit then TerminateScript(self.Quitmessage);

    if currentStep.completed then
    begin
      self.index += 1;
      DebugLn('Step Solved, going to next step');
      Wait(1000);
      attempts := 0;
      Continue;
    end else
      attempts += 1;
    DebugLn('Step failed on try ' + IntToStr(attempts));
    Antiban.RandomRotate();
    if attempts > 5 then TerminateScript('Failed to solve step: ' + currentStep.name + ' with index ' + IntToStr(self.index + 1));
  end;
  DebugLn('Quest solved');
end;

procedure TQuest.Run(MaxActions: UInt32; MaxTime: UInt64);

begin
  Self.Init(MaxActions, MaxTime);
  Self.Solve();
end;
